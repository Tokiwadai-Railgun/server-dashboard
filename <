use reqwest::Client;
use std::fmt;
use serde::{Deserialize, Serialize};
use reqwest::header;
use std::env;

pub struct ProxmoxClient {
    pub client: Client,
    pub base_url: String,
}

#[derive(Debug)]
pub enum ClientError {
    HeaderValueError,
    ClientGenerationError
}

#[derive(Debug, Serialize, Deserialize)]
pub struct VMIpResponse {
    result: Vec<InterfaceData>
}


#[derive(Debug, Serialize, Deserialize)]
pub struct InterfaceData{
    #[serde(rename = "hardware-address")]
    hardware_address: String,
    name: String,
    #[serde(rename = "ip-addresses")]
    ip_addresses: Vec<InterfaceIP>

}

#[derive(Debug, Serialize, Deserialize)]
pub struct InterfaceIP {
    #[serde(rename = "ip-address")]
    ip_address: String,
    prefix: u8,
    #[serde(rename = "ip-address-type")]
    ip_address_type: String
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ProxmoxResonse<T> {
    data: T
}

// ----- Structs shared with proxmox_request module -----
#[derive(Deserialize, Serialize)]
#[derive(Debug)]
pub struct VMInfo {
    vmid: u8,
    name: String,
    status: String,
    maxmem: u64,
    mem: u64,
    cpus: u8,
    cpu: f32,
    uptime: u64,
    ip: Vec<String>,
    maxdisk: u64,
    disk: u64
}

#[derive(Deserialize, Serialize)]
pub struct VMInfoResponse {
    data: Vec<VMInfo>
}

impl fmt::Display for ClientError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ClientError::HeaderValueError => write!(f,"Error Creating header value"),
            ClientError::ClientGenerationError => write!(f, "Error Generating ")
        }
    }
}

// then implements functions to the client to use if needed
impl ProxmoxClient {
    pub fn new() -> Result<Self, ClientError> {
        let mut headers = header::HeaderMap::new();
        let token = get_token();

        let header_value: header::HeaderValue = match header::HeaderValue::from_str(&format!("PVEAPIToken={}", token)) {
            Ok(header) => header,
            Err(_) => return Err(ClientError::HeaderValueError),
        };

        headers.insert(
            header::HeaderName::from_static("authorization"), 
            header_value
        );

        let client = match Client::builder()
            .danger_accept_invalid_certs(true)
            .default_headers(headers)
            .build() {

            Ok(client) => client,
            Err(_) => return Err(ClientError::ClientGenerationError)
        };

        Ok(Self {
            client,
            base_url: "https://192.168.1.88:8006/api2/json".to_string(),
        })
    }

    pub async fn get_vm_list(&self) -> Result<Vec<VMInfo>, reqwest::Error> {
        let response = self.client.get("https://192.168.1.88:8006/api2/json/nodes/owomnipotent/qemu").send().await.unwrap();
        match  response.json::<Vec<VMInfo>>().await {
            Ok(json) => {
                for vm in &json {
                    println!("{:?}", vm);
                    return Ok(json);
                }
            }

        }
    }

    pub async fn get_vm_info(&self) {
        let mut ip_list: Vec<InterfaceIP> = Vec::new();
        let ip_response = self.client.get("https://192.168.1.88:8006/api2/json/nodes/owomnipotent/qemu/100/agent/network-get-interfaces").send().await;

        match ip_response{
            Ok(data) => {
                let json = data.json::<ProxmoxResonse<VMIpResponse>>().await.unwrap();
                println!("Reponse = {:?}", json);
                
                for interface in json.data.result {
                    let mut iter = interface.ip_addresses.into_iter();
                    ip_list.push(iter.find(|x| x.ip_address_type == "ipv4").unwrap());
                    // Add the list of IPs to the global response and also query disk usage
                }
            }
            Err(e) => {
                println!("An error occured : {}", e);
                {}
            }
        }
    }
}

fn get_token() -> String {
    env::var("PVEAPIToken").unwrap()
}
